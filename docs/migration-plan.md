# Migration Plan: AWS CDK â†’ Terraform

---

## 1. Migration Approach from CDK to Terraform

- Assess the current CDK-managed infrastructure to ensure all resources are stable and fully deployed.
- Export CloudFormation templates generated by CDK stacks as a reference.
- Generate initial Terraform HCL code using conversion tools or manual translation from CloudFormation templates.
- Refine and modularize the Terraform code to follow best practices.
- Migrate incrementally by starting with isolated microservices (e.g., Savings Plan Manager).
- Import existing AWS resources into Terraform state using `terraform import` to avoid resource recreation.
- Run Terraform in parallel with CDK during transition to prevent downtime and allow validation.
- Validate deployments in non-production environments before full cutover.
- Decommission CDK stacks after successful migration.

---

## 2. Structuring IaC for Teams, Environments, and Modules

- Organize Terraform code into reusable modules representing microservices and shared components, for example:
  - `modules/dynamodb/`
  - `modules/lambda/`
  - `modules/api_gateway/`
  - `modules/savings_plan/`
- Use separate directories or Terraform workspaces for environments such as `dev`, `staging`, and `prod` to isolate state and configuration.
- Employ remote state backends (e.g., S3 with DynamoDB locking) for state sharing and concurrency control.
- Define clear module interfaces with inputs and outputs for team collaboration.
- Enforce code reviews and CI/CD pipelines for Terraform changes to maintain quality and compliance.

---

## 3. Developer Experience Concerns

- Use `terraform plan` to preview changes before applying to catch errors and unintended modifications.
- Implement automated testing using tools like Terratest to validate infrastructure modules.
- Maintain DRY principles by using variables, locals, and modules to avoid duplication.
- Use `.tfvars` files or environment variables to manage environment-specific configurations.
- Apply formatting (`terraform fmt`) and linting (`tflint`) consistently to improve code readability.
- Integrate Terraform commands into CI/CD pipelines for automated validation and deployment.

---

## 4. Handling Existing CDK State and Inter-Service Dependencies

- Import existing AWS resources created by CDK into Terraform state with `terraform import` to maintain continuity.
- Carefully map CDK resource identifiers to Terraform resource addresses during import.
- Explicitly declare dependencies between Terraform resources using `depends_on` where necessary.
- Pass outputs from one module as inputs to dependent modules to model inter-service relationships clearly.
- Use remote state locking to prevent concurrent state modifications.
- Regularly run `terraform plan` to detect and reconcile any drift between Terraform state and actual infrastructure.

---

## 5. Sample CDK vs Terraform Comparison (Savings Plan Stack)

**CDK (TypeScript) snippet:**


const plansTable = new dynamodb.Table(this, 'PlansTable', {
partitionKey: { name: 'userId', type: dynamodb.AttributeType.STRING },
sortKey: { name: 'planId', type: dynamodb.AttributeType.STRING },
billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
encryption: dynamodb.TableEncryption.AWS_MANAGED,
pointInTimeRecovery: true,
removalPolicy: cdk.RemovalPolicy.RETAIN,
});

const planLambda = new lambda.Function(this, 'PlanManagerLambda', {
runtime: lambda.Runtime.NODEJS_20_X,
handler: 'handler.main',
code: lambda.Code.fromAsset('lambda/savings-plan/plan-manager'),
environment: {
PLANS_TABLE_NAME: plansTable.tableName,
},
retryAttempts: 2,
deadLetterQueueEnabled: true,
tracing: lambda.Tracing.ACTIVE,
});

plansTable.grantReadWriteData(planLambda);



**Terraform (HCL) equivalent:**

resource "aws_dynamodb_table" "plans_table" {
name = "PlansTable"
billing_mode = "PAY_PER_REQUEST"
hash_key = "userId"
range_key = "planId"

attribute {
name = "userId"
type = "S"
}

attribute {
name = "planId"
type = "S"
}

point_in_time_recovery {
enabled = true
}

server_side_encryption {
enabled = true
}

lifecycle {
prevent_destroy = true
}
}

resource "aws_lambda_function" "plan_manager" {
function_name = "PlanManagerLambda"
filename = "lambda/savings-plan/plan-manager.zip"
handler = "handler.main"
runtime = "nodejs20.x"

environment {
variables = {
PLANS_TABLE_NAME = aws_dynamodb_table.plans_table.name
}
}

tracing_config {
mode = "Active"
}
}



---

# Summary

- Adopt an incremental migration approach to minimize risk.
- Structure Terraform code modularly with clear environment isolation.
- Enhance developer experience with previews, testing, and DRY practices.
- Carefully import and manage existing CDK-managed resources and dependencies.
- The provided code comparison illustrates how CDK constructs map to Terraform resources.

---

*This document can be included as `docs/migration-plan.md` in your GitHub repository.*


---

